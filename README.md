I imported matplotlib and numpy in order to be able to use other functions or expressions such as the sine function and to be able to plot said functions using the plt command. Furthermore, by importing numpy I also could use the pi value.
Then, I defined the function create_sine_wave with the keyword def. 
Afterwards, I defined the parameter t, where t is a time array defined using np.linspace.
The variable t was defined from 0 to the duration with a standard sampling rate of 44.1 kHz. 
Then I entered the keyword return followed by sin(2Ï€ft), which meant that the create_sine_wave function would give as an output that function with the values that had been entered as frequency and duration.
Then I entered sine_wave = create_sine_wave(1,2) and then I plotted the sine graph by using plt.plot(sine_wave).I used plt.xlabel(), plt.ylabel() and plt.title() to add more information to my graph.

Afterwards, I created a different pyth on file named imported_function.py where I used the command "from signals_and_systems import create_sine_wave" which allowed the file to recognise the function as it had been already defined in the other module. As a result, I entered different values for both the frequencies and durations into the create_sine_wave function and then I defined each of those create_sine_wave functions as sine_wave_1, sine_wave_2, sine_wave_3 and sine_wave_4. For example: sine_wave_1 = create_sine_wave(2,2). I then started a different section of code with plt.figure(), so that when I ran the script, the graph would appear. I then defined the limit on the time axis by using plt.xlim(0,30000). Then, using the function plt.plot() I plotted the four different sine waves, each with their respective label. So as to make the graph as understandable as possible, I plotted two of the sine waves as dotted curves by using 'g:' and 'r:'. Then I used plt.xlabel(), plt.ylabel(), and plt.title() to include the labels on the axes and the title of the graph. Lastly, I ended the code with the command plt.show().

I created a unit step function by using the keyword def followed by the command return np.where(). The function np.where() works in the following manner: np.where(condition, output if the condition is true, output if the condition is not true). Then I created a periodic square wave function square_wave(t, period=1). I ensured that the function was periodic by using the "%" command and then defining my new time variable as "t_periodic = t % period". Moreover, the time variable t, has been defined using an np.linspace() function. Additionally, after the square_wave function had been defined I entered the keyword "return" followed by the function previously mentioned, np.where(). This time the np.where function's condition was t_periodic< period/2, so that it would look like as follows : np.where(t_periodic< period/2, 1, -1), meaning that if the value of t_periodic is less than 0.5 then the square_wave function will yield 1 and if t_periodic is not less than 0.5 then the square_wave function will yield -1.

For the unit_step_function(), I tested the step behavior by comparing the output against expected values at points around t=0. All this was done using the np.all_equal() function, where the it works the following way: np.all_equal(output yielded by function, expected output), so if the function works as expected, no errors will arise. For the create_sine_wave() function, I verified the output array length matches the expected array length, checking amplitude accuracy using np.isclose() with tolerance, and confirmed zero-amplitude signals produce all-zero outputs. Lastly, for the square_wave() function I checked that the length of the input time array is equal to the length of the output.
